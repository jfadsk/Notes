> Gulimall
>
> 商城业务

# 一、商品上架

> 上架的商品才可以在网站展示。上架的商品需要可以被检索。
>
> 1**、商品** Mapping
>
> 分析：商品上架在 es 中是存 sku 还是 spu？

1.  、检索的时候输入名字，是需要按照 sku 的 title 进行全文检索的

2.  、检索使用商品规格，规格是 spu 的公共属性，每个 spu 是一样的

3.  、按照分类 id 进去的都是直接列出 spu 的，还可以切换。

4.  、我们如果将 sku 的全量信息保存到 es 中（包括 spu 属性）就太多量字段了。

5.  、我们如果将 spu 以及他包含的 sku 信息保存到 es 中，也可以方便检索。但是 sku 属于

> spu 的级联对象，在 es 中需要 nested 模型，这种性能差点。

6.  、但是存储与检索我们必须性能折中。

7.  、如果我们分拆存储，spu 和 attr 一个索引，sku 单独一个索引可能涉及的**问题**。

> 检索商品的名字，如“手机”，对应的 spu 有很多，我们要分析出这些 spu 的所有关联属性， 再做一次查询，就必须将所有 spu_id 都发出去。假设有 1 万个数据，数据传输一次就10000\*4=4MB；并发情况下假设 1000 检索请求，那就是 4GB 的数据，，传输阻塞时间会很长，业务更加无法继续。
>
> 所以，我们如下设计，这样才是文档区别于关系型数据库的地方，宽表设计，不能去考虑数据库范式。
>
> 1）、PUT product

[TABLE]

[TABLE]

[TABLE]

## 2、上架细节

> 上架是将后台的商品放在 es 中可以提供检索和查询功能

1.  、hasStock：代表是否有库存。默认上架的商品都有库存。如果库存无货的时候才需要更新一下 es

2.  、库存补上以后，也需要重新更新一下 es

3.  、hotScore 是热度值，我们只模拟使用点击率更新热度。点击率增加到一定程度才更新热度值。

4.  、下架就是从 es 中移除检索项，以及修改 mysql 状态

> 商品上架步骤：

1.  、先在 es 中按照之前的 mapping 信息，建立 product 索引。

2.  、点击上架，查询出所有 sku 的信息，保存到 es 中

3.  、es 保存成功返回，更新数据库的上架状态信息。

## 3、数据一致性

1.  、商品无库存的时候需要更新 es 的库存信息

2.  、商品有库存也要更新 es 的信息

# 二、商品检索

## 1、检索业务分析

> 商品检索三个入口：

1.  ![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554608.jpeg)、选择分类进入商品检索

2.  、输入检索关键字展示检索页

![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554609.jpeg)

3.  ![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554610.jpeg)、选择筛选条件进入

> 检索条件&排序条件

- 全文检索：skuTitle

- 排序：saleCount、hotScore、skuPrice

- 过滤：hasStock、skuPrice 区间、brandId、catalogId、attrs

- 聚合：attrs

> 完整的 url 参数
>
> **keyword**= 小 米 &**sort**=saleCount_desc/asc&**hasStock**=0/1&**skuPrice**=400_1900&**brandId**=1 &**catalogId**=1&**attrs**=1_3G:4G:5G&**attrs**=2_骁龙 845&**attrs**=4_高清屏

## 2、检索语句构建

[TABLE]

[TABLE]

[TABLE]

[TABLE]

[TABLE]

> 3**、结果提取封装**
>
> **1、响应数据模型**

[TABLE]

[TABLE]

> **2、响应结果封装**

[TABLE]

[TABLE]

[TABLE]

[TABLE]

[TABLE]

[TABLE]

> **三、商品详情**
>
> 1**、详情数据**

![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554611.jpeg)

> 2**、查询详情**

[TABLE]

[TABLE]

> 3**、**sku **组合切换**
>
> \<**div class="box-attr clear" th:each="attr:\${item.saleAttr}"**\>
>
> \<**dl**\>
>
> \<**dt**\>选择\[\[\${attr.attrName}\]\]\</**dt**\>
>
> \<**dd th:each="vals:\${attr.attrValues}"**
>
> \>
>
> \<**a class="sku_attr_value"**
>
> **th:attr="skus=\${vals.skuIds},class=\${#lists.contains(#strings.listSplit(val s.skuIds,','), item.info.skuId.toString())?'sku_attr_value checked':'sku_attr_value'}"** \>
>
> \[\[\${vals.attrValue}\]\]
>
> *\<!-- \<img*
>
> *src="/static/item/img/59ddfcb1Nc3edb8f1.jpg" /\> --\>*
>
> \</**a**\>
>
> \</**dd**\>
>
> \</**dl**\>
>
> \</**div**\>
>
> 动态切换
>
> \$(**".sku_attr_value"**).click(**function**(){
>
> *//1、点击的元素先添加上自定义的属性。为了识别我们是刚才被点击的*
>
> **var** skus = **new *Array***();
>
> \$(**this**).addClass(**"clicked"**);
>
> **var** curr = \$(**this**).attr(**"skus"**).split(**","**);
>
> *//当前被点击的所有sku 组合数组放进去*
>
> skus.push(curr);
>
> *//去掉同一行的所有的checked*
>
> \$(**this**).parent().parent().find(**".sku_attr_value"**).removeClass(**"checked"**);
>
> \$(**"a\[class='sku_attr_value checked'\]"**).each(**function**(){

[TABLE]

# 四、购物车

## 1、购物车需求

1.  **、需求描述：**

- 用户可以在**登录状态**下将商品添加到购物车**【用户购物车/在线购物车】**

### 放入数据库

- **mongodb**

- ***放入 redis（采用）***

> 登录以后，会将**临时购物车**的数据全部合并过来，并清空**临时购物车；**

- 用户可以在**未登录状态**下将商品添加到购物车**【游客购物车/离线购物车/临时购物车】**

  - 放入 localstorage（客户端存储，后台不存）

  - cookie

  - WebSQL

### - 放入 redis（采用）

> 浏览器即使关闭，下次进入，**临时购物车**数据都在

- 用户可以使用购物车一起结算下单

- 给购物车**添加商品**

- 用户可以**查询自己的购物车**

- 用户可以在购物车中**修改购买商品的数量**。

- 用户可以在购物车中**删除商品**。

### 选中不选中商品

- 在购物车中展示商品优惠信息

- 提示购物车商品价格变化

## 、数据结构

![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554612.jpeg)

> 因此每一个购物项信息，都是一个对象，基本字段包括：

[TABLE]

> 另外，购物车中不止一条数据，因此最终会是对象的数组。即：

[TABLE]

> Redis 有 5 种不同数据结构，这里选择哪一种比较合适呢？Map\<String, List\<String\>\>

- 首先不同用户应该有独立的购物车，因此购物车应该以用户的作为 key 来存储，Value 是用户的所有购物车信息。这样看来基本的\`k-v\`结构就可以了。

- 但是，我们对购物车中的商品进行增、删、改操作，基本都需要根据商品 id 进行判断， 为了方便后期处理，我们的购物车也应该是\`k-v\`结构，key 是商品 id，value 才是这个商品的购物车信息。

> 综上所述，我们的购物车结构是一个双层 Map：Map\<String,Map\<String,String\>\>

- 第一层 Map，Key 是用户 id

- 第二层 Map，Key 是购物车中商品 id，值是购物项数据

## 、流程

> ![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554613.jpeg)参照京东
>
> user-key 是随机生成的 id，不管有没有登录都会有这个 cookie 信息。两个功能：新增商品到购物车、查询购物车。
>
> 新增商品：判断是否登录

- 是：则添加商品到后台 Redis 中，把 user 的唯一标识符作为 key。

- 否：则添加商品到后台 redis 中，使用随机生成的 user-key 作为 key。查询购物车列表：判断是否登录

- 否：直接根据 user-key 查询 redis 中数据并展示

- 是：已登录，则需要先根据 user-key 查询 redis 是否有数据。

  - 有：需要提交到后台添加到 redis，合并数据，而后查询。

  - 否：直接去后台查询 redis，而后返回。

## 2、临时购物车

[TABLE]

> 3**、登录购物车**

[TABLE]

> **五、订单**
>
> 1**、订单中心**
>
> 电商系统涉及到 3 流，分别时信息流，资金流，物流，而订单系统作为中枢将三者有机的集合起来。
>
> 订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这 些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。

## 1、订单构成

![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554614.jpeg)

### 1、用户信息

> 用户信息包括用户账号、用户等级、用户的收货地址、收货人、收货人电话等组成，用户账 户需要绑定手机号码，但是用户绑定的手机号码不一定是收货信息上的电话。用户可以添加 多个收货信息，用户等级信息可以用来和促销系统进行匹配，获取商品折扣，同时用户等级 还可以获取积分的奖励等

### 2、订单基础信息

> 订单基础信息是订单流转的核心，其包括订单类型、父/子订单、订单编号、订单状态、订单流转的时间等。

1.  订单类型包括实体商品订单和虚拟订单商品等，这个根据商城商品和服务类型进行区分。

2.  同时订单都需要做父子订单处理，之前在初创公司一直只有一个订单，没有做父子订单处理后期需要进行拆单的时候就比较麻烦，尤其是多商户商场，和不同仓库商品的时候， 父子订单就是为后期做拆单准备的。

3.  订单编号不多说了，需要强调的一点是父子订单都需要有订单编号，需要完善的时候可以对订单编号的每个字段进行统一定义和诠释。

4.  订单状态记录订单每次流转过程，后面会对订单状态进行单独的说明。

5.  订单流转时间需要记录下单时间，支付时间，发货时间，结束时间/关闭时间等等

### 3、商品信息

> 商品信息从商品库中获取商品的 SKU 信息、图片、名称、属性规格、商品单价、商户信息等，从用户下单行为记录的用户下单数量，商品合计价格等。

### 优惠信息

> 优惠信息记录用户参与的优惠活动，包括优惠促销活动，比如满减、满赠、秒杀等，用户使 用的优惠券信息，优惠券满足条件的优惠券需要默认展示出来，具体方式已在之前的优惠券 篇章做过详细介绍，另外还虚拟币抵扣信息等进行记录。
>
> 为什么把优惠信息单独拿出来而不放在支付信息里面呢？
>
> 因为优惠信息只是记录用户使用的条目，而支付信息需要加入数据进行计算，所以做为区分。

### 支付信息

1.  支付流水单号，这个流水单号是在唤起网关支付后支付通道返回给电商业务平台的支付流水号，财务通过订单号和流水单号与支付通道进行对账使用。

2.  支付方式用户使用的支付方式，比如微信支付、支付宝支付、钱包支付、快捷支付等。 支付方式有时候可能有两个——余额支付+第三方支付。

3.  商品总金额，每个商品加总后的金额；运费，物流产生的费用；优惠总金额，包括促销活动的优惠金额，优惠券优惠金额，虚拟积分或者虚拟币抵扣的金额，会员折扣的金额等 之和；实付金额，用户实际需要付款的金额。

> 用户实付金额=商品总金额+运费-优惠总金额

### 物流信息

> 物流信息包括配送方式，物流公司，物流单号，物流状态，物流状态可以通过第三方接口来 获取和向用户展示物流每个状态节点。

## 2、订单状态

### 待付款

> 用户提交订单后，订单进行预下单，目前主流电商网站都会唤起支付，便于用户快速完成支 付，需要注意的是待付款状态下可以对库存进行锁定，锁定库存需要配置支付超时时间，超 时后将自动取消订单，订单变更关闭状态。

### 已付款/待发货

> 用户完成订单支付，订单系统需要记录支付时间，支付流水单号便于对账，订单下放到 WMS
>
> 系统，仓库进行调拨，配货，分拣，出库等操作。

### 待收货/已发货

> 仓储将商品出库后，订单进入物流环节，订单系统需要同步物流信息，便于用户实时知悉物 品物流状态

### 已完成

> 用户确认收货后，订单交易完成。后续支付侧进行结算，如果订单存在问题进入售后状态

### 已取消

> 付款之前取消订单。包括超时未付款或用户商户取消订单都会产生这种订单状态。

### 售后中

> 用户在付款后申请退款，或商家发货后用户申请退换货。
>
> 售后也同样存在各种状态，当发起售后申请后生成售后订单，售后订单状态为待审核，等待 商家审核，商家审核通过后订单状态变更为待退货，等待用户将商品寄回，商家收货后订单 状态更新为待退款状态，退款到用户原账户后订单状态更新为售后成功。

## 2、订单流程

> 订单流程是指从订单产生到完成整个流转的过程，从而行程了一套标准流程规则。而不同的 产品类型或业务类型在系统中的流程会千差万别，比如上面提到的线上实物订单和虚拟订单 的流程，线上实物订单与 O2O 订单等，所以需要根据不同的类型进行构建订单流程。
>
> 不管类型如何订单都包括正向流程和逆向流程，对应的场景就是购买商品和退换货流程，正向流程就是一个正常的网购步骤：订单生成–\>支付订单–\>卖家发货–\>确认收货–\>交易成功。而每个步骤的背后，订单是如何在多系统之间交互流转的，可概括如下图

![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554615.jpeg)

> 1、订单创建与支付

1.  、订单创建前需要预览订单，选择收货信息等

2.  、订单创建需要锁定库存，库存有才可创建，否则不能创建

3.  、订单创建后超时未支付需要解锁库存

4.  、支付成功后，需要进行拆单，根据商品打包方式，所在仓库，物流等进行拆单

5.  、支付的每笔流水都需要记录，以待查账

6.  、订单创建，支付成功等状态都需要给 MQ 发送消息，方便其他系统感知订阅

> 2、逆向流程

1)  、修改订单，用户没有提交订单，可以对订单一些信息进行修改，比如配送信息， 优惠信息，及其他一些订单可修改范围的内容，此时只需对数据进行变更即可。

2)  、订单取消，**用户主动取消订单和用户超时未支付**，两种情况下订单都会取消订 单，而超时情况是系统自动关闭订单，所以在订单支付的响应机制上面要做支付的

> 限时处理，尤其是在前面说的下单减库存的情形下面，可以保证快速的释放库存。 另外需要需要处理的是促销优惠中使用的优惠券，权益等视平台规则，进行相应补回给用户。

3)  、退款，在待发货订单状态下取消订单时，分为缺货退款和用户申请退款。如果是 全部退款则订单更新为关闭状态，若只是做部分退款则订单仍需进行进行，同时生 成一条退款的售后订单，走退款流程。退款金额需原路返回用户的账户。

4)  、发货后的退款，发生在仓储货物配送，在配送过程中商品遗失，用户拒收，用户 收货后对商品不满意，这样情况下用户发起退款的售后诉求后，需要商户进行退款 的审核，双方达成一致后，系统更新退款状态，对订单进行退款操作，金额原路返 回用户的账户，同时关闭原订单数据。仅退款情况下暂不考虑仓库系统变化。如果 发生双方协调不一致情况下，可以申请平台客服介入。在退款订单商户不处理的情 况下，系统需要做限期判断，比如 5 天商户不处理，退款单自动变更同意退款。

## 3、幂等性处理

> 参照幂等性文档

## 4、订单业务

> **1、搭建环境**
>
> 订单服务引入页面，nginx 配置动静分离，上传静态资源到 nginx。编写 controller 跳转逻辑

## 2、订单确认页

![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554616.jpeg)

> ![](https://raw.githubusercontent.com/xqy-power/images/main/202308101554617.png)
>
> 可以发现订单结算页，包含以下信息：

1.  收货人信息：有更多地址，即有多个收货地址，其中有一个默认收货地址

2.  支付方式：货到付款、在线支付，不需要后台提供

3.  送货清单：配送方式（不做）及商品列表（根据购物车选中的 skuId 到数据库中查询）

4.  发票：不做

5.  优惠：查询用户领取的优惠券（不做）及可用积分（京豆）

### OrderConfirmVo

[TABLE]

[TABLE]

> **3、创建订单**
>
> 当用户点击提交订单按钮，应该收集页面数据提交到后台并生成订单数据。
>
> 1**、数据模型**

[TABLE]

[TABLE]

> 2**、防止超卖**
>
> 数据库 unsigned int 做最后的保证。

## 4、自动关单

> 订单超时未支付，需要取消订单

## 5、解锁库存

> 订单关闭，需要解锁已经占用的库存
>
> 库存锁定成功，订单回滚，保证最终一致性，也需要库存自动解锁
>
> 4、5 功能参照消息队列流程完成

# 六、秒杀

## 1、秒杀业务

> 秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流 + 异步 + 缓存（页面静态化）
>
> \+ 独立部署。
>
> 限流方式：

1.  前端限流，一些高并发的网站直接在前端页面开始限流，例如：小米的验证码设计

2.  nginx 限流，直接负载部分请求到错误的静态页面：令牌算法 漏斗算法

3.  网关限流，限流的过滤器

4.  代码中使用分布式信号量

5.  rabbitmq 限流（能者多劳：chanel.basicQos(1)），保证发挥所有服务器的性能。

## 2、秒杀流程

> 见秒杀流程图
>
> 3**、限流**
>
> 参照 Alibaba Sentinel
