# 	0.前言：

面对对象 是一种思想 而不是一种方法。

> **！！今天不学习明天变垃圾！！**

# 1.类的特点

对象调方法，方法改属性

方法可以被 多个对象分别调用 而属性是每个对象旗下所拥有的属性 各不相同。

# 2.几大区分布

栈区：由编译器为你开辟的空间，用完之后，编译器会为你回收空间，**栈区最大的特点是先进后出，避免内存错误释放**

堆区：由你自己开辟的空间 比如**new**一个对象，这个对象，要由你自己来**delete**。

# 3.建立类的基本步骤

1.  对类进行初始化 Ps： class person 也就是抽象的过程，观察类中所含的的属性特点
2.  根据需要写出构造在构造中完成数据初始化（与类同名，person（））与析构函数加~
3.  ![image-20210102094407238](https://i.loli.net/2021/01/02/W3AHqU8MjFigEDQ.png)
4.  构造函数 可以重载 也就是根据 传入参数类型 和 参数个数进行重载
5.  Base(const Base &); // 拷贝构造函数，通过对相同类的引用进行值的复制

#    4.类的几个特殊用法

### 4.1封装

![image-20201221162558790](https://i.loli.net/2020/12/22/t1BmhLPsGEZV9j7.png)

封装 的本质就是 利用 private 关键字  将数据进行 封装，简单点就理解为加密，毕竟一个人的个人信息不能被别人反复调用，而留下的函数，可以理解成，一个个接口，通过接口钥匙，进行访问 修改数据。

除了 private之外 还有一共三种访问权限 public protected private :

![image-20201221163233064](https://i.loli.net/2020/12/22/6EDhGVT7wS2eOXs.png)

### 4.2继承

在继承中，一个派生类，可以存在多个父类，同时继承多个父类的函数，数据类型。

如果父类中存在同名单元，利用作用域进行调用不同父类中的成员（我为啥要写重名。。。。）

继承也有常见的三种方式。![image-20201215182647505](https://i.loli.net/2020/12/22/Jzt3puDNvZC2Sb1.png)

需要注意 private性质的数据 即使被继承 也不能被调用，可以理解为，完全隐藏了此数据。

#### 4.2.1继承中的深浅拷贝问题

#####   4.2.1浅拷贝

除了构造函数，编译器在一个类创建完毕后，也会给你预留一个简单的拷贝函数，利用拷贝函数，可以做到，两个类中的值进行赋值，例如 class person 后 person p1；person p2（p1）；这就是最简单的拷贝函数。

在浅拷贝中虽然也能完成对新对象的赋值，但是也存在着一定的问题。

就是 多个对象公用同一块地址，会导致释放的时候，重复释放，导致出错。

![img](https://i.loli.net/2020/12/22/1XILWutla4PwoUH.png)

##### 4.2.1深拷贝

所以深拷贝 就是用来解决，同一块空间被反复释放的问题。

在实行拷贝的时候 在堆区new出一块新地址进行指向赋值，用完释放就行。

new的返回值是一个指针 需要一个指针去承接他。

![image-20201217185640223](https://i.loli.net/2020/12/22/NaBkc3lZUtHPgGw.png)

![image-20201220104028811](https://i.loli.net/2020/12/22/kXrVSE7dOWcZ5Fy.png)

#### 4.2.2虚继承解决二义性，也就是多继承问题。

利用 virtual 关键字进行虚继承，能使子类只保留一个父类属性。

在实际中应该避免菱形继承问题。



### 4.3多态

多态也分为静态多态和动态多态

#### 4.3.1静态多态

​			常见的函数重载就是最简单的静态多态，根据传入参数的数量，类型，进行多态判定。

![image-20201215174215589](https://i.loli.net/2020/12/22/NOvqTrLSHsg8yBk.png)

#### 4.3.2动态多态

1. 其实要实现动态多态，需要几个条件——即动态绑定条件：
   虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
   通过基类类型的指针或引用来调用虚函数。
2. 有一个父类指针引用子类对象来完成多态的过程。
3. 有一定继承关系

且在多态实现过程中 一定会出现 函数重写的问题。

![](https://i.loli.net/2020/12/22/YQxSp6KvVzi7fRt.png)

<img src="C:\Users\Lenovo\Desktop\笔记\8lhNIz4EGicMOqg.png" alt="image-20201216132043613" style="zoom:150%;" />

这个就是比较简单的 函数重写 问题。

### 4.4友元

> 声明一个类作为另一个类的朋友，相互可以访问。

#### 4.4.1利用全局做友元单位

![image-20201215142826450](https://i.loli.net/2020/12/22/21igZ6MdXvjUpFo.png)

#### 4.4.2同时 类也能做友元单位。

![image-20201215144526597](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201215144526597.png)

#### 4.4.3个别函数也能声明为友元单位 进行调用

![image-20201215145447117](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201215145447117.png)

### 4.5引用

int a；int &ra=a；说明ra是a的一个别名，用到了引用。

1. &在这并不是求地址，而就是起一个指向的作用。
2. 类型标识符是指向目标变量的类型
3. ### 引用 一但声明 必须有指向，**不能空引用**。
4. 引用有专一性，不能二次声明。
5. 引用不占有储存单元。
6. 无法对数组建立引用，因为一个数组有多个地址。
7. 在传入参数时，传地址，和传引用，作用相同。

### 4.6静态成员

用关键字 static 进行声明一个静态成员或者函数，能别所有的类调用！其实就是一个全局静态变量！

------

//类内声明，类外定义
class xxx
{
	static 数据类型 静态数据成员名;
}
数据类型 类名::静态数据成员名=初值
//访问
类名::静态数据成员名;
对象名.静态数据成员名;
对象指针名->静态数据成员名;

------

//类内声明，类外定义
class xxx
{
	static 返回值类型 静态成员函数名(参数列表);
}
返回值类型 类名::静态成员函数名(参数列表)
{
	函数体;
}
//访问
类名::静态成员函数名(参数列表);
对象名.静态成员函数名(参数列表);
对象指针名->静态成员函数名(参数列表);

------

### 4.7文件操作

和c相差不大 头文件发生了改变！直接写**fstream**就完事了！

![image-20201221164417605](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20201221164417605.png)

#### 4.7.1写文件的具体操作

1. 头文件（略）
2. 创建流对象//可以理解为一个写文件的工具或者连接编译器和文件的桥梁。
3. 打开文件 类似于c的**fopen**
4. 写
5. 关闭文件 类似于c的**fclose**

![image-20201221164840333](https://i.loli.net/2020/12/22/XSRzQIH67WliFYx.png)

#### 4.7.2读文件的具体操作

同理，能写就能读

![image-20201221170435149](https://i.loli.net/2020/12/22/Es4pA1BDy8gfexv.png)

注意，读与写不一样的地方在于，写可以创建文件，而读的时候文件必须已经存在，你需要先判断一手，文件是否存在或者文件是否能正确打开！

**也就是这个操作：**

![image-20201221170716907](https://i.loli.net/2020/12/22/M85v1GtLweUbjIc.png)

读取方法：

1. 一行一行来，设置一个足够大的字符串，利用字符串容纳一行的信息做输出![image-20201221171523088](https://i.loli.net/2020/12/22/AJLQG2kFV1dbgHW.png)
2. 利用    getline  做一行读取，比较简单
3. ![image-20201221171832562](https://i.loli.net/2020/12/22/wuJpq39nz8KWjPx.png)

#### 4.7.3文件的打开方式



![image-20201221164959590](https://i.loli.net/2020/12/22/mAIes8FGSCwnyiz.png)



从文本文档读入链表。

![image-20201230200714109](https://i.loli.net/2020/12/30/wEsth2knRQoKdpN.png)

![image-20201230203722782](https://i.loli.net/2020/12/30/vwfAuJ6sZqRnSBT.png)

### 4.8“.”和“->”的使用区别

这两个符号都是[C++成员运算符](http://www.runoob.com/cplusplus/cpp-member-operators.html)，主要用于确定类对象和成员之间的关系，用于引用类、结构和共用体的成员。

点运算符“.”应用于实际的对象，箭头运算符“->”与一个指针对象的指针一起使用。

class A
{
public:
	int a = 0;
};
int main()
{
	A b;
	A *p = &b;
	b.a; //类类型的对象访问类的成员
	p->a; //类类型的指针访问类的成员
}

# 5.案例

## 5.1组装计算机

利用多态进行不同的设备制造。

![image-20201224103347408](https://i.loli.net/2020/12/24/Qf2TzaWbgnpGSeN.png)

抽象出来基类，因为用不到，利用纯虚函数进行声明（意思就是，每个零件都是一个需要抽象出来的基类）

比较简单的方法，就是你一个大的类里所包括的东西，不能用常规int char 等关键字表达出来的时候，就要思考，是不是需要一个class用来产生了一个类，就如同一台电脑，需要的是CPU，CPU总不能通过int出来，所以你得创造一个CPU的类。

![img](https://i.loli.net/2020/12/24/P6pj4bDBXomWU51.png)